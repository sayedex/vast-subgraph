type Collection @entity(immutable: false) {
  id: ID!

  creator: Bytes!
  address: Bytes!

  collectionSize: BigInt!
  totalMinted: BigInt!

  platformFee: BigInt!           # New field: fee percentage in basis points
  platformFeeRecipient: Bytes!   # New field: address of the fee recipient

  metadataUri: String!
  name:String!
  symbol:String!

  collectionType: String! # SINGLE | MULTI

  createdAt: BigInt!
  ended: Boolean!

  # publicSale: PublicSaleConfig!
  # presale: PresaleConfig!
  editions: [Edition!]! @derivedFrom(field: "collection")
}


type Edition @entity(immutable: false)  {
  id: ID!                      # {collection}-{tokenId}

  collection: Collection!

  tokenId: BigInt!             # 0 for ERC721, real id for 1155

  maxSupply: BigInt!
  totalMinted: BigInt!

  uri: String!

  publicSale: PublicSaleConfig
  presales: [PresaleConfig!]! @derivedFrom(field: "edition")  # one-to-many
}




type PublicSaleConfig @entity(immutable: false){
  id: ID!                      # {editionId}-public

  edition: Edition!

  price: BigInt!
  maxPerWallet: BigInt!

  startTime: BigInt!
  endTime: BigInt!

}


type PresaleConfig @entity(immutable: false) {
  id: ID!                      # {editionId}-presale

  edition: Edition!

  price: BigInt!
  maxPerWallet: BigInt!
  presaleSupply: BigInt!
  presaleMinted: BigInt!
  startTime: BigInt!
  endTime: BigInt!

  merkleRoot: Bytes!

}



type Mint @entity(immutable: true) {
  id: ID!
  collection: Collection!
  user: Bytes!
  quantity: BigInt!
  type: String!
  timestamp: BigInt!
}



type PlatformStats @entity(immutable: false) {
  id: ID!                     # Use a constant ID, e.g., "platform"

  totalRevenue: BigInt!       # Total platform fees accrued across all collections
  totalCollections: BigInt!   # Total collections created
  singleCollections: BigInt!  # Count of SINGLE type collections
  multiCollections: BigInt!   # Count of MULTI type collections
  totalMinted: BigInt!        # Total NFTs minted across all collections
}
